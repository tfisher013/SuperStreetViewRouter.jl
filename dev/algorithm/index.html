<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithm · SuperStreetViewRouter.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://tfisher013.github.io/SuperStreetViewRouter.jl/algorithm/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../example_usage/">SuperStreetViewRouter.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../example_usage/">Example Usage</a></li><li class="is-active"><a class="tocitem" href>Algorithm</a><ul class="internal"><li><a class="tocitem" href="#Depth-Searched-Enhanced-Greedy-BFS"><span>Depth Searched-Enhanced Greedy BFS</span></a></li><li><a class="tocitem" href="#Search-Parameters"><span>Search Parameters</span></a></li><li><a class="tocitem" href="#Analysis"><span>Analysis</span></a></li><li><a class="tocitem" href="#Areas-For-Improvement"><span>Areas For Improvement</span></a></li></ul></li><li><a class="tocitem" href="../">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Algorithm</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Algorithm</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/tfisher013/SuperStreetViewRouter.jl/blob/main/docs/src/algorithm.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Algorithm"><a class="docs-heading-anchor" href="#Algorithm">Algorithm</a><a id="Algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithm" title="Permalink"></a></h1><p><code>SuperStreetViewRouter.jl</code> uses a depth searched-enhanced greedy algorithm with optimizations to maximize traversed distance over the provided city input file. The algorithm&#39;s implementation and ideas for how it can be improved are described below.</p><p>Before continuing, it will be helpful to first familiarize yourself with the details of the <a href="https://storage.googleapis.com/coding-competitions.appspot.com/HC/2014/hashcode2014_final_task.pdf">Google 2014 HashCode problem</a>, as references to aspects of the problem will be made throughout.</p><h2 id="Depth-Searched-Enhanced-Greedy-BFS"><a class="docs-heading-anchor" href="#Depth-Searched-Enhanced-Greedy-BFS">Depth Searched-Enhanced Greedy BFS</a><a id="Depth-Searched-Enhanced-Greedy-BFS-1"></a><a class="docs-heading-anchor-permalink" href="#Depth-Searched-Enhanced-Greedy-BFS" title="Permalink"></a></h2><p>The algorithm performs the same routine for each car sequentially.</p><ol><li>Enumerate all paths of <code>depth</code> edges from current junction that can be traversed in remaining time.</li><li>Select the path which generates the greatest value.</li><li>Travel <code>n_steps</code> along the selected path, updating remaining time with the travel cost.</li><li>Repeat from 1 until remaining time prohibits further travel.</li></ol><h3 id="Path-Value"><a class="docs-heading-anchor" href="#Path-Value">Path Value</a><a id="Path-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Path-Value" title="Permalink"></a></h3><p>To compare paths in terms of the benefit they will confer on itinerary score, we use the following metric:</p><p>The value of a path consisting of a list of <span>$n$</span> junctions is given by</p><p class="math-container">\[\sum_{i=1}^{n-1} d_{i,i+1}\]</p><p>where <span>$d_{i, i+1}$</span> is the penalized distance (see information on penalties below) of traversing the street between junctions <span>$i$</span> and <span>$i+1$</span>.</p><h3 id="Traversal-Penalty"><a class="docs-heading-anchor" href="#Traversal-Penalty">Traversal Penalty</a><a id="Traversal-Penalty-1"></a><a class="docs-heading-anchor-permalink" href="#Traversal-Penalty" title="Permalink"></a></h3><p>Since streets which have already been traversed once no longer add to the final itinerary score, the algorithm incorporates  a traversal penalty to artificially deflate the distance of traversed streets when scoring paths. The idea is that streets  with no or a low number of traversals will be selected over streets with a high number of traversals.</p><p>Our penalty function is of the following form:</p><p class="math-container">\[f(x, n, p) = x * p^n\]</p><p class="math-container">\[x\]</p><p>is the distance of the street assuming <span>$0$</span> traversals <span>$n$</span> is the number of times the street has been traversed <span>$p$</span> is the parameter <code>elapsed_street_penalty</code></p><h2 id="Search-Parameters"><a class="docs-heading-anchor" href="#Search-Parameters">Search Parameters</a><a id="Search-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Search-Parameters" title="Permalink"></a></h2><p>All tunable algorithm parameters can be provided when calling <code>solve_graph_greedy()</code>:</p><ul><li><code>elapsed_street_penalty</code> controls the penalization accrued by traversed streets.</li><li><code>depth</code> controls the maximum depth to which each BFS invocation will run.</li><li><code>n_steps</code> is the number of street edges traversed once an optimal path of depth <code>depth</code> has been determined. Note that </li><li><code>n_steps</code> <span>$\leq$</span> <code>depth</code> as the depth of our BFS limits how many steps forward can be taken per iteration.</li></ul><h2 id="Analysis"><a class="docs-heading-anchor" href="#Analysis">Analysis</a><a id="Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Analysis" title="Permalink"></a></h2><p>!!!In Progress!!!</p><p>The upper bound of the algorithm can be described as the maximum score achievable on a given city data of which we know some  information. In this section, a reasonable upper bound will be derived beginning from simple assumptions and gradually accounting for increasing complexity.</p><p>Let&#39;s begin by considering a City object whose streets so exceed the number of cars and total duration that all cars can run freely  without fear of overlap. Here we assume that the traversal penalty described above is sufficient to prevent overlap in the presence  of an abudance of available streets. With all <span>$\text{num}\textunderscore\text{cars}$</span> cars running for <span>$\text{total}\textunderscore\text{duration}$</span>  seconds each, there are <span>$\text{num}\textunderscore\text{cars} \cdot \text{total}\textunderscore\text{duration}$</span> seconds during which  streets will be traversed.</p><p>To generate a distance score from the available time, we introduce a normalized average rate for the City object as described below:</p><p class="math-container">\[\text{norm}\textunderscore\text{avg}\textunderscore\text{speed} = \frac{\displaystyle \sum_{s \in S} s_d \cdot \frac{s_d}{s_t}}{\displaystyle \sum_{s \in S} s_d}\]</p><p class="math-container">\[S\]</p><p>is the set of streets in the the city</p><p class="math-container">\[s_d\]</p><p>is the distance of street <span>$s \in S$</span></p><p class="math-container">\[s_t\]</p><p>is the duration of street <span>$s \in S$</span></p><p>Using this value as an approximation for the typical speed at which a car can traverse any given street in the City object, we arrive  at a idyllic upper bound <span>$b_{u}$</span> (measured in meters) of</p><p class="math-container">\[b_{u} \leq \text{num}\textunderscore\text{cars} \cdot \text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed}\]</p><p>Now applying this model to a more general City object requires accounting for two possibilities related to scarcity:</p><ol><li>Suppose a City object contains less distance in its streets than the value obtained from the expression above?</li><li>Suppose cars are forced to overlap one another in the course of their paths?</li></ol><p>Handling the first situation is simple. We cap our bound at the total distance of the City object:</p><p class="math-container">\[b_{u} \leq \min(\text{num}\textunderscore\text{cars} \cdot \text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed}, d_{total})\]</p><p>where <span>$d_{total}=\sum_{s \in S} s_d$</span></p><p>To address overlap, consider how its effect ranges from absolute (the score of <span>$n$</span> cars is equivalent to the score of  <span>$1$</span>) to non-existent (ideal model above). Expressed in terms of our quantities,</p>$<p>\min(\text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed},  d<em>{total}) \leq b</em>{u} \leq \min(\text{num}\textunderscore\text{cars} \cdot \text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed}, d_{total}) $</p><p>To simplify our expression, let&#39;s condense the effect of overlap into a single factor, <span>$o_f$</span>, like so:</p><p class="math-container">\[b_{u} \leq \min(\text{num}\textunderscore\text{cars} \cdot \text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed} \cdot o_f, d_{total})\]</p><p>where <span>$\frac{1}{\text{num}\textunderscore\text{cars}} \leq o_f \leq 1$</span></p><p>A simple way to construct <span>$o_f$</span> is to relate it to the following ratio, which represents what portion of the city <span>$1$</span> car  could traverse on its own:</p><p class="math-container">\[\frac{\text{total}\textunderscore\text{duration} \cdot \text{norm}\textunderscore\text{avg}\textunderscore\text{speed}}{d_{total}}\]</p><p>!!!In Progress!!!</p><h2 id="Areas-For-Improvement"><a class="docs-heading-anchor" href="#Areas-For-Improvement">Areas For Improvement</a><a id="Areas-For-Improvement-1"></a><a class="docs-heading-anchor-permalink" href="#Areas-For-Improvement" title="Permalink"></a></h2><p>There are several ideas relating to BFS that could likely improve performance. Performance improvements themselves do not  increase score, but allow for increased depth (which may augment score) in a manageable amount of time.</p><ul><li>Trimming BFS set periodically either by value, randomness, or the similarity between paths.</li><li>Pre-allocating and considering only a set number of length <code>depth</code> paths per BFS routine to decrease runtime memory allocations.</li><li>Applying threading to each iteration of BFS as next-step paths are generated independently.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../example_usage/">« Example Usage</a><a class="docs-footer-nextpage" href="../">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Wednesday 7 December 2022 23:36">Wednesday 7 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
